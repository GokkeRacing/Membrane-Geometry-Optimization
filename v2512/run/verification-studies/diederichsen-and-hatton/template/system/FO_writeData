writeData
{
    libs ("libutilityFunctionObjects.so");
    type coded;
    name writeData;
    enabled yes;
    writeControl writeTime;

    codeInclude
    #{
        #include "fvCFD.H"
        #include <fstream>
        #include <map>
    #};

    codeWrite
    #{

    // Read parameters from settings file
    std::ifstream settingsFile("overview");
    std::map<word, scalar> params;
    
    word key;
    scalar value;
    while (settingsFile >> key >> value)
    {
        params[key] = value;
    }
    settingsFile.close();

    label nLayers = label(params["n_z"]);
    
    // Lookup fields
    const volScalarField& S = mesh().lookupObject<volScalarField>("C_S");
    const volScalarField& CO2 = mesh().lookupObject<volScalarField>("C_CO2");
    const volVectorField& C = mesh().C();
    const scalarField& V = mesh().V();
    
    // Get minimum and maximum z coordinates
    scalar minZ = GREAT;
    scalar maxZ = -GREAT;
    forAll(C, cellI)
    {
        scalar z = C[cellI].component(2);
        minZ = min(minZ, z);
        maxZ = max(maxZ, z);
    }
    
    reduce(minZ, minOp<scalar>());
    reduce(maxZ, maxOp<scalar>());
    
    // Gather all z-coordinates to master for global sorting
    List<scalar> allZ(C.size());
    forAll(C, cellI)
    {
        allZ[cellI] = C[cellI].component(2);
    }
    
    // Combine lists from all processors
    List<List<scalar>> gatheredZ(Pstream::nProcs());
    gatheredZ[Pstream::myProcNo()] = allZ;
    Pstream::gatherList(gatheredZ);
    
    // Flatten and broadcast
    List<scalar> globalZ;
    if (Pstream::master())
    {
        label totalSize = 0;
        forAll(gatheredZ, proci)
        {
            totalSize += gatheredZ[proci].size();
        }
        
        globalZ.setSize(totalSize);
        label idx = 0;
        forAll(gatheredZ, proci)
        {
            forAll(gatheredZ[proci], i)
            {
                globalZ[idx++] = gatheredZ[proci][i];
            }
        }
    }
    Pstream::broadcast(globalZ);
    
    // Sort globally and determine layer boundaries
    Foam::sort(globalZ);
    label totalCells = globalZ.size();
    label cellsPerLayer = max(1, totalCells / nLayers);
    
    scalarField layerBoundaries(nLayers + 1);
    layerBoundaries[0] = minZ - SMALL;
    for (label i = 1; i < nLayers; i++)
    {
        label idx = min(i * cellsPerLayer, totalCells - 1);
        layerBoundaries[i] = globalZ[idx];
    }
    layerBoundaries[nLayers] = maxZ + SMALL;
    
    // Initialize arrays for each layer
    scalarField layerS_sum(nLayers, 0.0);
    scalarField layerCO2_sum(nLayers, 0.0);
    scalarField layerVolume(nLayers, 0.0);
    scalarField layerZ_sum(nLayers, 0.0);
    
    // Accumulate values for each layer based on global boundaries
    forAll(C, cellI)
    {
        scalar z = C[cellI].component(2);
        
        // Find which layer this cell belongs to
        label layerIdx = 0;
        for (label i = 0; i < nLayers; i++)
        {
            if (z >= layerBoundaries[i] && z < layerBoundaries[i+1])
            {
                layerIdx = i;
                break;
            }
        }
        
        layerS_sum[layerIdx] += S[cellI] * V[cellI];
        layerCO2_sum[layerIdx] += CO2[cellI] * V[cellI];
        layerVolume[layerIdx] += V[cellI];
        layerZ_sum[layerIdx] += z * V[cellI];
    }
    
    // Sum across all processors
    if (Pstream::parRun())
    {
        reduce(layerS_sum, sumOp<scalarField>());
        reduce(layerCO2_sum, sumOp<scalarField>());
        reduce(layerVolume, sumOp<scalarField>());
        reduce(layerZ_sum, sumOp<scalarField>());
    }
    
    // Write data to file in time directory
    if (Pstream::master())
    {
        fileName outputFile_S = "S.csv";
        fileName outputFile_CO2 = "CO2.csv";
        std::ofstream outS(outputFile_S);
        std::ofstream outCO2(outputFile_CO2);
        outS.precision(12);
        outCO2.precision(12);
        outS << "#z S" << std::endl;
        outCO2 << "#z CO2" << std::endl;
        
        forAll(layerS_sum, layerIdx)
        {
            if (layerVolume[layerIdx] > VSMALL)
            {
                // Volume-weighted average z position for this layer
                scalar z = layerZ_sum[layerIdx] / layerVolume[layerIdx];
                scalar S_avg = layerS_sum[layerIdx] / layerVolume[layerIdx];
                scalar CO2_avg = layerCO2_sum[layerIdx] / layerVolume[layerIdx];
                outS << z << ", " << S_avg << std::endl;
                outCO2 << z << ", " << CO2_avg << std::endl;
            }
        }
        outS.close();
        outCO2.close();
        
        Info << "Layer-averaged data written to " << outputFile_S << " and " << outputFile_CO2 << endl;
    }
    
    #};
}